<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="../webcomponentsjs/webcomponents-lite.min.js"></script>
  <link rel="import" href="./google-codelab-elements.html">
  <link rel="import" href="./google-codelab-step.html">
  <style>
    #contentContainer {
      background-color: #e0e0e0;
    }
    #topBar {
      background-color: #39464e !important;
    }
  </style>
</head>
<body unresolved>
    <google-codelab title="Measure Widgets">
      <google-codelab-step label="Introduction" step="1" duration="3">
          <p>
            <img 
                style="max-width: 400.00px;    
                       display: block;
                        margin-left: auto;
                        margin-right: auto" 
                src="./static/result.jpg" 
                width="100" 
                alt="">   
          </p>
          <p>In this Falcong In-front workshop, You'll create a fully working Measure Widget combining
              <a href="https://github.com/FalconSocial/falcon-ng-components/blob/master/readme.md" target="_blank">
                falcon ng components
            </a>  
              using the <code>widget component</code>,
                <a href="https://github.com/reactjs/redux/blob/master/README.md" target="_blank">
                    Redux
                </a> and 
                <a href="https://github.com/reactjs/reselect/blob/master/README.md" target="_blank">
                    Reselect
                </a>.
            </p>
            <h3>What you'll learn</h3>
            <ul class="checklist">
                <li>How to create a widget using falcon components.</li>
                <li>How to use a mock service that returns data for your widget.</li>
                <li>Understand the flow of data using Redux store.</li>
                <li>How to create a selector using Reselect that enhaces the performance of Redux.</li>
                <li>How to use transformers to parse your data.</li>
            </ul>
            <h3>What you'll need</h3>
            <ul>
                <li>
                    Basic knowledge of JS, HTML and CSS
                </li>
                <li>
                    Basic understanding of Redux
                </li>
            </ul>
          
      </google-codelab-step>
      <google-codelab-step label="Widget definition" step="2" duration="3">
        <p>Let's start by creating the definition of your widget.</p>  
        <p>You will need to go to the /widgets/widget.ts file and add a new key to the object that corresponds to the id of your widget.</p>  
        <h3>Widget interface</h3>
        <p>A widget has the following properties: </p>
        <ul>
            <li><b>id: String</b>(Mandatory) : Needs to be <b>unique</b></li>
            <li><b>template: String </b>(Mandatory) : Name of your template with .html</li>
            <li><b>metrics: String[] </b>(Mandatory) : Name of the metrics used.</li>
            <li><b>serviceId: String </b>(Mandatory) : Name of your service in metrics reducer.</li>
            <li><b>title: String </b>(Optional)</li>
            <li><b>description : String</b> (Optional)</li>
            <li><b>size: String </b>(Optional) : size of your widget. <b>small(default)/medium/large</b> </li>
            
        </ul>
        <h3>Example</h3>
        <pre>
            <code>const widgets = {
                brands_fans: {
                    metrics: ["brands_fans_total", "brands_fans_new"],
                    template: "brandsChart.html",
                    id: "brands_fans",
                    description: "This is the description of a widget",
                    title: "Fans",
                    serviceId: "brand_service",
                    size: "small"
                }
            }
            </code>
        </pre>
      </google-codelab-step>
      <google-codelab-step label="Create a mock service" step="3" duration="3">
         <p>
             Since the actual service asking the backend for data will live in the Html-Client
            we need to mock a service that will return a response with the same format.
        </p> 

          <p>First lets register the service in the metric reducer using our serviceId.</p> 
          <p>
            In the variable called serviceMap, add your new service id, calling the angular service that you will have in the html client.  
          </p>
        <h3>Example:</h3> 
          <pre>
            <code>const serviceMap = {
                    brand_service: (...args) => 
                        $injector.get('brandOverviewAPIService')
                            .getBrandsMetrics(...args)
                };
            </code>
        </pre> 
        <p>For the purpose of this workshop the <code>brandOverviewAPIService</code>
            service has been created for you. 
        </p>
        <p>
            Understand how the service uses mock helper functions to return a different format depending on the metric. 
        </p>
        <p>
            This mock functions will take into account your selections as period and sources to return more realistic data.
        </p>
        <p>
            Include your metric/s in the response you expect. 
            In this case <code>mockLineChart</code>.
        </p>         
      </google-codelab-step>
      <google-codelab-step label="Create selector" step="6" duration="5">
          <h3>Reselect</h3>
        First, lets understand what is a selector and its power.
        <ul>
            <li> Selectors can compute derived data, allowing Redux to store the minimal possible state.
            </li>
            <li>Selectors are efficient. A selector is not recomputed unless one of its arguments change.
            </li>
            <li>Selectors are composable. They can be used as input to other selectors.
            </li>
        </ul>
        <p>
            Reselect provides a function <code>createSelector</code> that takes and array of input-selectors and a transform function of it arguments.    
        </p>
        <p>
            If the state tree changes it will call the input selectors to check if any of its arguments have changed. If not it will return the previously computed value.
        </p>

        <pre>
            <code>const shopItemsSelector = state => state.shop.items;
            const taxPercentSelector = state => state.shop.taxPercent;
            const taxItemsSelector = createSelector(
                shopItemsSelector,
                taxPercentSelector,
                (items, taxPercent) => items.reduce((acc, item) => acc + item.value, 0) * taxPercent;
            )
            </code>
        </pre>
        <p>
            Only when <code>state.shop.items</code> or <code>state.shop.taxPercent</code> changes the transform function will be recomputed.
        </p>
        <h3>Coding</h3>
        <p>Once we have undertand the theory, let's put it into practice.</p>
        <p>We have to think what parts of the store our transfor function is expecting.</p>
        <p>For our case we need the <code>raw data</code> that our service returns and the <code>channelGroups</code> resource.</p>
        <p>Therefore we need a <code>metricSelector</code> and a <code>channelGroupSelector</code></p>
        <pre>
            <code>const channelGroupsSelector = (state, props) => state.resources.channelsGroups; 
            const metricsSelector = (state, props) => state.measure.metrics[props.id]; 
            const widgetSelector = createSelector([channelGroupsSelector, metricsSelector], 
                (channelGroups,metricsSelector) => {
                     //Your transform function will go here. 
            });
            </code>
        </pre>

        <p>Note: The props is coming from the measureWidgetComponent controller when we connect to the store and call the selector with the state and the widgetId</p>
      </google-codelab-step>
      <google-codelab-step label="Create a transformer function" step="4" duration="5">
            <p>We have created our first selector, so lets create our transformer function.</p>
            <p>As we have seen in the previous step, this function will receive the channelGroups and the raw data as parameters</p>            
            <pre><code>const widgetDataParser = (rawData, channelGroups) => {})</code></pre>
            <p>
                The rawData is a metric coming from the store, a metric has the following properties:
                <ul>
                    <li><code>id</code></li>
                    <li><code>data</code></li>
                    <li><code>serviceId</code></li>
                    <li><code>fetching</code></li>
                    <li><code>failed</code></li>
                </ul>
            </p>
            <p>We have to add some sageguars in case the metric failed or we have no data</p>
            <pre>
                <code>if(rawData.failed || 
                   !rawData.data || 
                   !Object.keys(rawData.data).length) {
                        return rawData;
                    }</code>
            </pre>
            <p> So we have to return the data prepared for our visualization.</p>
            <p> In the /selectors/transformers/ we have a couple of visualization parser functions that will help with it.</p>
            <p> The <code>line chart parser</code> expects the <code>metric data</code> and some <code>sources</code>.</p>
            <p> The <code>key metric parser</code> expects the <code>metric data</code> and some <code>aggregation function</code>.</p>
            <pre>
                <code>const lineTotal = parseLineChartData(rawData.data.brands_fans_total, channelGroups);
                const keyMetricTotal = parseKeyMetricSeries(rawData.data.brands_fans_total, last);
                </code>
            </pre>
            <p>We will do the same for our second metric and return the parsed ready for its visualization</p>
            <pre>
                <code>const parsedData = [
                    {
                        name: 'Total',
                        keyMetric: keyMetricTotal,
                        lineTotal
                    },
                    {
                        name: 'New',
                        keyMetric: keyMetricNew,
                        line: lineNew
                    }]
            
                    return { ...rawData, parsedData };
                </code>
            </pre>
    </google-codelab-step>
    <google-codelab-step label="Create a template" step="5" duration="5">
          <p>You have done all the most difficult parts!!</p>
          <p>Lets consume our prepared data in our falcon components</p>

          <p>First of all create an html file in /wdigets/templates/ with the same name you had in your widget definition.</p> 
          <p>Then, lets think about the pieces we need for our widget:</p> 
          <p> We will use:
              <ul>
                  <li>
                        <code>fang-metric</code> for the numbers.
                  </li>
                  <li>
                        <code>fang-button</code> so the metrics are clickable.
                  </li>
                  <li>
                        <code>fang-linechart</code> for the bottom chart.
                  </li>
                  <li>
                        <code>fang-loader fang-loader-wrapper</code> to handle loadig times in the widget.
                  </li>
                  <li>
                        <code>fang-card</code> for the widget container.
                  </li>
              </ul>
           </p>
           <p>So let's import them in our index.ts in src to tell my angular module that we will use them</p>
           <pre>
               <code>const mod = angular.module('falconWidget.measureWidgets', [
                    components.loader.name,
                    components.card.name,
                    components.button.name,
                    components.lineChart.name,
                    components.metric.name,
                    components.loaderWrapper.name
                    ]);
                </code>
            </pre>
            <p>Now that we have our components imported, lets use them in our template</p>
            <p>Lets start by showing the widget title and description in the fang-card</p>
            <pre>
                <code><textarea readonly><fang-card size="small">
                    <fang-card-content>
                        <span class="eyas-fs2 eyas-type--bold">{{$ctrl.widget.title}}</span>
                        <span class="eyas-icon eyas-icon-info eyas-ml5" bs-tooltip data-title="{{$ctrl.widget.description}}"></span>
                    </fang-card-content>
                    </fang-card>
                </textarea>
                </code>
            </pre>
            <p>
                Then lets add the loader wrapper for our component. Since we are also sending the raw data with our parsed data, 
                we know when we are fething the metrics.
            </p>
            <pre>
                <code><textarea readonly><div style="min-height:274px">
                    <fang-loader-wrapper loading="$ctrl.redux.metrics.fetching && !$ctrl.redux.metrics.failed" style="min-height: inherit;">
                    </fang-loader-wrapper>
                </div></textarea>
                </code>
            </pre>
            <p> And finally lets use our fang-metric and fang-linechart</p>
            <pre>
                <code><textarea readonly><div class="eyas-layout">
                        <fang-button
                            ng-repeat="dataItem in $ctrl.redux.metrics.parsedData"
                            state="link"
                            class="eyas-layout eyas-layout--center eyas-ml10 eyas-mr10 eyas-pb5"
                            style="width: 100%;"
                        >
                            <fang-metric label="{{ dataItem.name }}" value="dataItem.keyMetric"></fang-metric>
                        </fang-button>
                    </div>
                    <div class="eyas-box eyas-box--smallest">
                        <fang-line-chart 
                            ng-if="$ctrl.redux.metrics.parsedData[0].line"
                            series="$ctrl.redux.metrics.parsedData[0].line.series"
                            config="$ctrl.redux.metrics.parsedData[0].line.config">
                        </fang-line-chart>
                    </div>
                    </textarea>
                </code>
            </pre>
            <p>BOOM our widget loos shiny and amazing.</p>         
          
      </google-codelab-step>
      <google-codelab-step label="Extra visualizations?" step="7" duration="5">
          <p>We are almost done...</p>
          <p>We are missing interactions in the module to click on the specific line chart metric we want to show.</p>
          <p>For that if you go to widgets/visualizations, there is a component created for you with one binding as the data and with the click interaction.</p>
          <p>Note: Remember to register your visualization components in our src/index.ts</p>
          <pre>
              <code><textarea readonly><div style="min-height:274px"></div>
                    <fang-loader-wrapper loading="$ctrl.redux.metrics.fetching && !$ctrl.redux.metrics.failed" style="min-height: inherit;">
                        <key-metrics-line-chart ng-if="$ctrl.redux.metrics.parsedData" data="$ctrl.redux.metrics.parsedData"></key-metrics-line-chart>
                    </fang-loader-wrapper>
                </div>
              </textarea>
              </code>
          </pre>
      </google-codelab-step>
</google-codelab>
</body>
</html>